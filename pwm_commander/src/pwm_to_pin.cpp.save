#include "ros/ros.h"
#include "std_msgs/String.h"
#include <wiringPi.h>
#include <softPwm.h>
#include <stdio.h>
#include <sstream>

//How fast should we go?
int throttle = 0;
//Constants
const int PIN1 = 12;
const int PIN2 = 16;
const int PWM_RANGE = 200;

/*Required Subfunction declaration*/
void init_motor(int pin_number);
int* throttle2pwmValues(int throttle);

void pwmValCallback(const std_msgs::String::ConstPtr& msg)
{
  const char* num = msg->data.c_str();
  throttle = std::stoi(num,nullptr,10);
  int* pwmValues = throttle2pwmValues(throttle);
  softPwmWrite(PIN1,pwmValues[0]);
  softPwmWrite(PIN2,pwmValues[1]);
}

int main(int argc, char **argv)
{
  /*
  * Init Node.
  * This node recieves the constantly published values of topic 
  * "pwm_const" and puts them on the desired GPIO pin.
  */
  ros::init(argc, argv, "pwm_to_pin");
  ros::NodeHandle n;

  /*Init Subscriber functionality*/
  ros::Subscriber sub = n.subscribe("pwm_const", 1000, pwmValCallback);

  /*Init wiringPi functionality*/
  //WiringPi Vlaues
  wiringPiSetupPhys();
  softPwmCreate(PIN1,0,PWM_RANGE);
  softPwmCreate(PIN2,0,PWM_RANGE);


  /*Arm Motors*/
  init_motor(PIN1);
  init_motor(PIN2);

  ROS_INFO("Starting main programm.");
  while(ros::ok())
  {
    ros::spinOnce();
  }

  return 0;
}

void init_motor(int pin_number)
{
   ROS_INFO("Duty Cycle = 0%%");
   softPwmWrite(pin_number,10);
   ROS_INFO("Connect Motor Now...");
   delay(5000);
   ROS_INFO("Listen for 'BEEEP---BEEEP. Should be armed.'");
}

int* throttle2pwmValues(int throttle)
{
  int* pwmValues = new int[2];
  //pwmValues[0]= 100;
  //pwmValues[1]= 100-throttle;
  //First Wheel always runs at 100% == 2 ms pulse length,
  //Second Wheel is slowed down to increase overall throttle,
  //Lowest pulse width 0% == 1 ms
  pwmValues[0] = PWM_RANGE/10;
  pwmValues[1] = PWM_RANGE/10 - throttle/100.0 * (PWM_RANGE/20);
  return pwmValues;
}
